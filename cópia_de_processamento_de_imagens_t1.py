# -*- coding: utf-8 -*-
"""Cópia_de_Processamento_de_imagens_T1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/guilhermegreis/processamento-de-img/blob/main/C%C3%B3pia_de_Processamento_de_imagens_T1.ipynb

#Trabalho sobre Filtragem e Morfologia - Guilherme G. Reis e Thiago Trainotti.
#Utilizamos algumas coisas que vimos que poderiam ser reutilizáveis do último trabalho apresentado. Tentamos criar funções de filtragem e operações pontuais à mão conforme solicitado na descrição do trabalho. Porém, em casos como mostrar uma imagem ou coisas do tipo, achamos que não seria necessária fazer funções à mão.

#Lendo imagem e mostrando
"""

import numpy as np
from matplotlib import pyplot as plt
import cv2
from google.colab.patches import cv2_imshow

#função para carregar a imagem e também convertar para escala de cinza
def load_img(path):
    img = cv2.imread(path) #utilizamos o cv2 para ler, pois achamos que para casos como estes estaria tudo bem utilizar funções prontas do cv2
    if img is None:
        print("Imagem não encontrada")
        return None

    gray = np.dot(img[..., :3], [0.2989, 0.5870, 0.1140]) #converter para a escala cinza
    return img, gray

#função para adicionar ruído gaussiano
def add_gaussian_noise(img, mean=0, std_dev=25):
    noise = np.random.normal(mean, std_dev, img.shape).astype(np.uint8) #criar ruido com distribuição gaussiana
    noisy_img = np.clip(img + noise, 0, 255) #garantir os valores entre 0 e 255
    return noisy_img

#ler as imagens
img_path = '/content/Cerebro-RaioX.jpg'
img_path2 = '/content/juggernaut.jpg'
color1, gray1 = load_img(img_path)
color2, gray2 = load_img(img_path2)

#verificaçao se estamos subindo as imagens corretas e no caminho correto
if gray1 is not None and gray2 is not None:

    #adicionar ruído nas imagens em tons de cinza
    noisy_gray1 = add_gaussian_noise(gray1, mean=0, std_dev=25)
    noisy_gray2 = add_gaussian_noise(gray2, mean=0, std_dev=25)

    #daqui até o fim deste bloco de código seria para mostrar as imagens, em escala cinza, com ruído e também a colorida do Juggernaut
    plt.figure(figsize=(12, 6))

    plt.subplot(2, 2, 1)
    plt.imshow(gray1, cmap='gray')
    plt.title('Imagem 1 Original- Escala de Cinza')
    plt.axis('off')

    plt.subplot(2, 2, 2)
    plt.imshow(noisy_gray1, cmap='gray')
    plt.title('Imagem 1 com Ruído - Escala de Cinza')
    plt.axis('off')

    plt.subplot(2, 2, 3)
    plt.imshow(cv2.cvtColor(color2, cv2.COLOR_BGR2RGB))
    plt.title('Imagem 2 Original - Colorida')
    plt.axis('off')

    plt.subplot(2, 2, 4)
    plt.imshow(noisy_gray2, cmap='gray')
    plt.title('Imagem 2 com Ruído - Escala de Cinza')
    plt.axis('off')

    plt.tight_layout()
    plt.show()

"""#Filtro da média (suavização)"""

import math
import matplotlib.pyplot as plt
import numpy as np

#criaçao kernel da media e com uma matriz com valores iguais -> size 3, 3x3
def create_mean_kernel(size):
  return np.ones((size, size)) / (size * size)

#aplicaçao do kernel na imagem, calculo da media ponderada e ter a img suavizada
def convulation(img, kernel):
  k = kernel.shape[0]
  pad = k//2
  height, width = img.shape
  padded = np.zeros((height + 2 * pad, width + 2 * pad), dtype=np.float32)

  #colocar a imagem para o centro do pad
  for i in range(height):
    for j in range(width):
      padded[i + pad, j + pad] = img[i, j]

  output = np.zeros((height, width), dtype=np.float32)

  for i in range(height):
    for j in range(width):
      acc = 0.0
      for m in range(k):
        for n in range(k):
          acc += padded[i + m, j + n] * kernel[m, n]
      output[i, j] = acc
  return np.clip(output, 0, 255).astype(np.uint8)

#aplicar filtros de convulaçao com tamanhos variados, no caso 3x3, 5x5 e 7x7
def apply_mean_filters(img, kernel_sizes=[3, 5, 7]):
  results = []
  for size in kernel_sizes:
    kernel = create_mean_kernel(size)
    filtered = convulation(img, kernel)
    results.append({
        'size': size,
        'mean': filtered
    })
  return results

#exibir imagens
def display_mean_filters(original, noisy, filtered_original, filtered_noisy):
    total = 2 + len(filtered_original) + len(filtered_noisy)
    cols = 3
    rows = math.ceil(total / cols)

    plt.figure(figsize=(5 * cols, 4 * rows))

    #imagem original
    plt.subplot(rows, cols, 1)
    plt.imshow(original, cmap='gray')
    plt.title("Imagem Original")
    plt.axis('off')

    # imagem com ruido
    plt.subplot(rows, cols, 2)
    plt.imshow(noisy, cmap='gray')
    plt.title("Imagem com Ruído")
    plt.axis('off')

    #filtros aplicados na imagem original
    for i, res in enumerate(filtered_original):
        plt.subplot(rows, cols, i + 3)
        plt.imshow(res['mean'], cmap='gray')
        plt.title(f'Média {res["size"]}x{res["size"]} (Original)')
        plt.axis('off')

    #filtros aplicados na imagem com ruido
    for i, res in enumerate(filtered_noisy):
        plt.subplot(rows, cols, i + 3 + len(filtered_original))
        plt.imshow(res['mean'], cmap='gray')
        plt.title(f'Média {res["size"]}x{res["size"]} (Com Ruído)')
        plt.axis('off')

    plt.tight_layout()
    plt.show()

#adicionar ruido gaussiano
def add_gaussian_noise(image, mean=0, sigma=25):
    row, col = image.shape
    gauss = np.random.normal(mean, sigma, (row, col))
    noisy = np.clip(image + gauss, 0, 255).astype(np.uint8)
    return noisy

#ler as imgs
img_path = 'Cerebro-RaioX.png'
img = load_img(img_path)
img_path2 = 'juggernaut.png'
img2 = load_img(img_path2)

#verificaçao das imagens
if img is not None:
    #ruído nas imagens
    noisy_img = add_gaussian_noise(img)
    noisy_img2 = add_gaussian_noise(img2)

    filtered_original = apply_mean_filters(img)
    filtered_noisy = apply_mean_filters(noisy_img)

    filtered_original2 = apply_mean_filters(img2)
    filtered_noisy2 = apply_mean_filters(noisy_img2)

    display_mean_filters(img, noisy_img, filtered_original, filtered_noisy)
    display_mean_filters(img2, noisy_img2, filtered_original2, filtered_noisy2)

"""Filtro da mediana (remoção de ruído)"""

import matplotlib.pyplot as plt
import numpy as np


#funçao para aplicar padding
def pad_image(img, pad):
    height = len(img)
    width = len(img[0])
    new_height = height + 2 * pad
    new_width = width + 2 * pad

    padded = [[0 for _ in range(new_width)] for _ in range(new_height)]

    for i in range(height):
        for j in range(width):
            padded[i + pad][j + pad] = img[i][j]
    return padded

#calculo da mediana
def median(values):
    sorted_vals = sorted(values)
    n = len(sorted_vals)
    mid = n // 2
    if n % 2 == 0:
        return (sorted_vals[mid - 1] + sorted_vals[mid]) // 2
    else:
        return sorted_vals[mid]

#filtro da mediana
def median_filter(img, k=3):
    pad = k // 2
    height = len(img)
    width = len(img[0])
    padded = pad_image(img, pad)

    result = [[0 for _ in range(width)] for _ in range(height)]

    for i in range(height):
        for j in range(width):
            window = []
            for ki in range(k):
                for kj in range(k):
                    window.append(padded[i + ki][j + kj])
            result[i][j] = median(window)

    return np.array(result, dtype=np.uint8)

#aplicaçao do filtro de mediana com varios tamanhos
def apply_filters_medians(img, sizes=[3, 5, 7]):
    results = []
    for k in sizes:
        result = median_filter(img, k)
        results.append((k, result))
    return results

#exibiçao
def show_results(original, noisy, median_results, img_name="Imagem"):
    total = 2 + len(median_results)
    cols = 3
    rows = math.ceil(total / cols)

    plt.figure(figsize=(5 * cols, 4 * rows))

    #imagem original
    plt.subplot(rows, cols, 1)
    plt.imshow(original, cmap='gray')
    plt.title(f"{img_name} Original")
    plt.axis('off')

    #imagem com ruido
    plt.subplot(rows, cols, 2)
    plt.imshow(noisy, cmap='gray')
    plt.title(f"{img_name} com Ruído")
    plt.axis('off')

    #filtros aplicados na imagem com ruido
    for i, (k, img_filt) in enumerate(median_results, start=3):
        plt.subplot(rows, cols, i)
        plt.imshow(img_filt, cmap='gray')
        plt.title(f"Mediana {k}x{k}")
        plt.axis('off')

    plt.tight_layout()
    plt.show()

#execuçao
img = load_img("Cerebro-RaioX.png")
img2 = load_img("juggernaut.png")
noisy_img = add_gaussian_noise(img)
noisy_img2 = add_gaussian_noise(img2)

#filtros de mediana nas imagens com ruido
median_results = apply_filters_medians(noisy_img)
median_results2 = apply_filters_medians(noisy_img2)

#imagens originais e com ruido junto com os filtros de mediana
show_results(img, noisy_img, median_results, img_name="Cérebro")
show_results(img2, noisy_img2, median_results2, img_name="Juggernaut")

"""Filtro Laplaciano (realce de bordas)"""

import cv2
from google.colab.patches import cv2_imshow
import numpy as np

#funcao de converter a imagem BGR para listas de listas
def bgr_to_list(img_cv2):
    return [[tuple(pixel) for pixel in row] for row in img_cv2]

#converter imagem BGR para tons de cinza
def rgb_to_gray(img_color):
    height = len(img_color)
    width = len(img_color[0])
    gray = [[0 for _ in range(width)] for _ in range(height)]
    for i in range(height):
        for j in range(width):
            b, g, r = img_color[i][j]
            gray[i][j] = int(0.299 * r + 0.587 * g + 0.114 * b)
    return gray

#padding
def pad_image(img, pad=1):
    height = len(img)
    width = len(img[0])
    padded = [[0 for _ in range(width + 2 * pad)] for _ in range(height + 2 * pad)]
    for i in range(height):
        for j in range(width):
            padded[i + pad][j + pad] = img[i][j]
    return padded

#filtro Laplaciano
def laplacian_filter(img):
    kernel = [[0, -1, 0], #mascara
              [-1, 4, -1],
              [0, -1, 0]]
    padded = pad_image(img, 1)
    height = len(img)
    width = len(img[0])
    result = [[0 for _ in range(width)] for _ in range(height)]

    for i in range(height):
        for j in range(width):
            soma = 0
            for ki in range(3):
                for kj in range(3):
                    valor_pixel = padded[i + ki][j + kj]
                    valor_kernel = kernel[ki][kj]
                    soma += valor_pixel * valor_kernel
            #clamping
            result[i][j] = min(255, max(0, soma))

    result_img = np.array(result, dtype=np.uint8)
    return result_img

#aplicacao dos filtros e exibiçao
img_cerebro = cv2.imread("/content/Cerebro-RaioX.png")
img_juggernaut = cv2.imread("/content/juggernaut.png")

img_cerebro_list = bgr_to_list(img_cerebro)
img_juggernaut_list = bgr_to_list(img_juggernaut)

img_cerebro_gray = rgb_to_gray(img_cerebro_list)
img_juggernaut_gray = rgb_to_gray(img_juggernaut_list)

laplaciano_cerebro = laplacian_filter(img_cerebro_gray)
laplaciano_juggernaut = laplacian_filter(img_juggernaut_gray)

cv2_imshow(laplaciano_cerebro)
cv2_imshow(laplaciano_juggernaut)

"""#Filtro Passa-Baixa com Fourier

"""

import numpy as np
import cv2
import matplotlib.pyplot as plt

#filtro passa-baixa
def createPB(shape, center, radius, lpType=2, n=2):
    rows, cols = shape[:2]
    r, c = np.mgrid[0:rows, 0:cols]
    c -= center[0]
    r -= center[1]
    d = np.sqrt(r**2 + c**2)

    if lpType == 0:  #Ideal
        lpFilter = np.zeros(shape, np.float32)
        lpFilter[d <= radius] = 1
    elif lpType == 1:  #Butterworth
        lpFilter = 1 / (1 + (d / (radius + 1e-5))**(2 * n))
    elif lpType == 2:  #Gaussiano
        lpFilter = np.exp(-(d**2) / (2 * (radius**2)))

    return lpFilter

#DFT 2D
def dft2d(img):
    M, N = img.shape
    x = np.arange(M)
    y = np.arange(N)
    u = x.reshape((M, 1))
    v = y.reshape((N, 1))
    W_M = np.exp(-2j * np.pi * u * x / M)
    W_N = np.exp(-2j * np.pi * v * y / N)
    return W_M @ img @ W_N.T

#IDFT 2D inversa
def idft2d(dft_img):
    M, N = dft_img.shape
    x = np.arange(M)
    y = np.arange(N)
    u = x.reshape((M, 1))
    v = y.reshape((N, 1))
    W_M_inv = np.exp(2j * np.pi * u * x / M)
    W_N_inv = np.exp(2j * np.pi * v * y / N)
    return np.real(W_M_inv @ dft_img @ W_N_inv.T) / (M * N)

#carregamento das imagens
img1 = cv2.imread("Cerebro-RaioX.png", cv2.IMREAD_GRAYSCALE).astype(np.float32) / 255.0
img2 = cv2.imread("juggernaut.png", cv2.IMREAD_GRAYSCALE).astype(np.float32) / 255.0

#aplicar o passa-baixa
def filtrar(img):
    f = dft2d(img)
    fshift = np.fft.fftshift(f) #centralizar a frequencia
    rows, cols = img.shape
    center = (cols // 2, rows // 2)
    mask = createPB((rows, cols), center, radius=30, lpType=2) #mascara gaussiana
    filtered = fshift * mask
    f_ishift = np.fft.ifftshift(filtered)
    img_back = idft2d(f_ishift)
    return img_back, mask

#aplicar o filtro
img1_back, mask1 = filtrar(img1)
img2_back, mask2 = filtrar(img2)

#exibir os resultados
plt.figure(figsize=(12, 8))

plt.subplot(2, 3, 1)
plt.title("Original Cérebro")
plt.imshow(img1, cmap='gray')
plt.axis('off')

plt.subplot(2, 3, 2)
plt.title("Filtro Cérebro")
plt.imshow(mask1, cmap='gray')
plt.axis('off')

plt.subplot(2, 3, 3)
plt.title("Filtrada Cérebro")
plt.imshow(img1_back, cmap='gray')
plt.axis('off')

plt.subplot(2, 3, 4)
plt.title("Original Juggernaut")
plt.imshow(img2, cmap='gray')
plt.axis('off')

plt.subplot(2, 3, 5)
plt.title("Filtro Juggernaut")
plt.imshow(mask2, cmap='gray')
plt.axis('off')

plt.subplot(2, 3, 6)
plt.title("Filtrada Juggernaut")
plt.imshow(img2_back, cmap='gray')
plt.axis('off')

plt.tight_layout()
plt.show()

"""#Filtro Passa-Alta com Fourier"""

import numpy as np
import cv2
import matplotlib.pyplot as plt

#criaçao do filtro passa-alta
def createPA(shape, center, radius, lpType=2, n=2):
    rows, cols = shape[:2]
    r, c = np.mgrid[0:rows, 0:cols]
    c = c - center[0]
    r = r - center[1]
    d = np.sqrt(np.power(r, 2) + np.power(c, 2))

    if lpType == 0: #Ideal,
        lpFilter = np.copy(d)
        lpFilter[d <= radius] = 0
        lpFilter[d > radius] = 1
    elif lpType == 1: #Butterworth, mais suave
        lpFilter = 1 / (1 + (radius / (d + 1e-5)) ** (2 * n))
    elif lpType == 2: #Gaussiano, mais suave que o Butterworth
        lpFilter = 1 - np.exp(-(d ** 2) / (2 * (radius ** 2)))

    return lpFilter.astype(np.float32)

#multiplicar a matriz de fourier na direçao das linhas e colunas
def dft2d(img):
    M, N = img.shape
    x = np.arange(M)
    y = np.arange(N)
    u = x.reshape((M, 1))
    v = y.reshape((N, 1))
    W_M = np.exp(-2j * np.pi * u * x / M)
    W_N = np.exp(-2j * np.pi * v * y / N)
    return W_M @ img @ W_N.T

#reconstruir a imagem original a partir do dominio de frequencia
def idft2d(dft_img):
    M, N = dft_img.shape
    x = np.arange(M)
    y = np.arange(N)
    u = x.reshape((M, 1))
    v = y.reshape((N, 1))
    W_M_inv = np.exp(2j * np.pi * u * x / M)
    W_N_inv = np.exp(2j * np.pi * v * y / N)
    return np.real(W_M_inv @ dft_img @ W_N_inv.T) / (M * N)

#carregar imagens
img1 = cv2.imread("Cerebro-RaioX.png", cv2.IMREAD_GRAYSCALE).astype(np.float32) / 255.0
img2 = cv2.imread("juggernaut.png", cv2.IMREAD_GRAYSCALE).astype(np.float32) / 255.0

#aplicar o filtro passa-alta
def aplica_passa_alta(img, radius=30):
    f = dft2d(img)
    fshift = np.fft.fftshift(f)
    rows, cols = img.shape
    center = (cols // 2, rows // 2)
    mask = createPA((rows, cols), center, radius, lpType=2)
    filtered = fshift * mask
    f_ishift = np.fft.ifftshift(filtered)
    img_back = idft2d(f_ishift)
    img_back = np.abs(img_back)
    return img_back, mask

#aplicar o filtro
img1_filt, mask1 = aplica_passa_alta(img1)
img2_filt, mask2 = aplica_passa_alta(img2)

plt.figure(figsize=(12, 6))

plt.subplot(2, 3, 1)
plt.title("Original - Cérebro")
plt.imshow(img1, cmap='gray')
plt.axis('off')

plt.subplot(2, 3, 2)
plt.title("Filtro Cérebro")
plt.imshow(mask1, cmap='gray')
plt.axis('off')

plt.subplot(2, 3, 3)
plt.title("Filtrada - Cérebro")
plt.imshow(img1_filt, cmap='gray')
plt.axis('off')

plt.subplot(2, 3, 4)
plt.title("Original - Juggernaut")
plt.imshow(img2, cmap='gray')
plt.axis('off')

plt.subplot(2, 3, 5)
plt.title("Filtro Juggernaut")
plt.imshow(mask2, cmap='gray')
plt.axis('off')

plt.subplot(2, 3, 6)
plt.title("Filtrada - Juggernaut")
plt.imshow(img2_filt, cmap='gray')
plt.axis('off')

plt.tight_layout()
plt.show()

"""#Passa-banda"""

import numpy as np
import cv2
import matplotlib.pyplot as plt

#criaçao do filtro passa-banda
def createPF(shape, center, bandCenter, bandWidth, lpType=2, n=2):
    rows, cols = shape[:2]
    r, c = np.mgrid[:rows, :cols]
    c -= center[0]
    r -= center[1]
    d = np.sqrt(r**2 + c**2)
    if lpType == 0:  # Ideal
        lpFilter = np.zeros_like(d)
        lpFilter[(d >= bandCenter - bandWidth / 2) & (d <= bandCenter + bandWidth / 2)] = 1
    elif lpType == 1:  # Butterworth
        lpFilter = 1 / (1 + ((d * bandWidth) / (d**2 - bandCenter**2 + 1e-5))**(2 * n))
    elif lpType == 2:  # Gaussian
        lpFilter = np.exp(-((d - bandCenter) ** 2) / (2 * (bandWidth / 2) ** 2))
    return lpFilter

#processamento da imagem com o passa-banda
def process_image_rf(image_path, bandCenter=1, bandWidth=400, lpType=2, n=2):
    img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
    img = cv2.resize(img, (256, 256)) #redimensionamento da imagem, tivemos que fazer testes porque o tamanho fazia demorar muito esse bloco de código
    img_float = np.float32(img)

    #transformada em fourier
    dft = cv2.dft(img_float, flags=cv2.DFT_COMPLEX_OUTPUT)
    dft_shift = np.fft.fftshift(dft)

    #calculo da magnitude do espectro
    magnitude_spectrum_original = 20 * np.log(cv2.magnitude(dft_shift[:, :, 0], dft_shift[:, :, 1]) + 1)

    center = (img.shape[1] // 2, img.shape[0] // 2)
    mask = createRF(dft_shift.shape[:2], center, bandCenter, bandWidth, lpType=lpType, n=n)

    filtered_freq = np.zeros_like(dft_shift)
    filtered_freq[:, :, 0] = dft_shift[:, :, 0] * mask
    filtered_freq[:, :, 1] = dft_shift[:, :, 1] * mask

    #espectro depois da filtragem
    magnitude_spectrum_filtered = 20 * np.log(cv2.magnitude(filtered_freq[:, :, 0], filtered_freq[:, :, 1]) + 1)

    #transformada inversa pra reconstruir a imagem filtrada
    f_ishift = np.fft.ifftshift(filtered_freq)
    img_back = cv2.idft(f_ishift)
    img_back = cv2.magnitude(img_back[:, :, 0], img_back[:, :, 1])
    img_back = cv2.normalize(img_back, None, 0, 255, cv2.NORM_MINMAX).astype(np.uint8)

    return img, img_back, magnitude_spectrum_original, magnitude_spectrum_filtered

#processar as imagens
img1, img_back1, mag_orig1, mag_filt1 = process_image("Cerebro-RaioX.png")
img2, img_back2, mag_orig2, mag_filt2 = process_image("juggernaut.png")

# Exibição
plt.figure(figsize=(12, 8))

plt.subplot(3, 2, 1)
plt.imshow(img1, cmap='gray')
plt.title('Original 1 - Cérebro')

plt.subplot(3, 2, 3)
plt.imshow(mag_orig1, cmap='gray')
plt.title('Espectro Original 1')

plt.subplot(3, 2, 5)
plt.imshow(mag_filt1, cmap='gray')
plt.title('Espectro com Filtro 1')

plt.subplot(3, 2, 2)
plt.imshow(img2, cmap='gray')
plt.title('Original 2 - Juggernaut')

plt.subplot(3, 2, 4)
plt.imshow(mag_orig2, cmap='gray')
plt.title('Espectro Original 2')

plt.subplot(3, 2, 6)
plt.imshow(mag_filt2, cmap='gray')
plt.title('Espectro com Filtro 2')

plt.tight_layout()
plt.show()

"""#Rejeita-banda"""

import numpy as np
import cv2
import matplotlib.pyplot as plt

#filtro rejeita-banda
def createRF(shape, center, bandCenter, bandWidth, lpType=2, n=2):
    rows, cols = shape[:2]
    r, c = np.mgrid[:rows, :cols]
    c -= center[0]
    r -= center[1]
    d = np.sqrt(r**2 + c**2)
    if lpType == 0:  # Ideal
        rf = np.ones_like(d)
        rf[(d >= bandCenter - bandWidth / 2) & (d <= bandCenter + bandWidth / 2)] = 0
    elif lpType == 1:  # Butterworth
        rf = 1 / (1 + ((bandWidth * d) / (np.square(d) - bandCenter**2 + 1e-5))**(2 * n))
    elif lpType == 2:  # Gaussiano
        rf = 1 - np.exp(-((d - bandCenter) ** 2) / (2 * (bandWidth / 2) ** 2))
    return rf

#filtro no dominio da frequencia
def process_image_rf(image_path, bandCenter=50, bandWidth=50, lpType=2, n=2):
    img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE) #escala cinza
    img = cv2.resize(img, (256, 256)) #redimensionamento
    img_float = np.float32(img)

    dft = cv2.dft(img_float, flags=cv2.DFT_COMPLEX_OUTPUT)
    dft_shift = np.fft.fftshift(dft)

    #magnitude do espectro
    magnitude_spectrum_original = 20 * np.log(cv2.magnitude(dft_shift[:, :, 0], dft_shift[:, :, 1]) + 1)

    #gerar a mascara
    center = (img.shape[1] // 2, img.shape[0] // 2)
    mask = createRF(dft_shift.shape[:2], center, bandCenter, bandWidth, lpType=lpType, n=n)

    filtered_freq = np.zeros_like(dft_shift)
    filtered_freq[:, :, 0] = dft_shift[:, :, 0] * mask
    filtered_freq[:, :, 1] = dft_shift[:, :, 1] * mask

    magnitude_spectrum_filtered = 20 * np.log(cv2.magnitude(filtered_freq[:, :, 0], filtered_freq[:, :, 1]) + 1)

    f_ishift = np.fft.ifftshift(filtered_freq)
    img_back = cv2.idft(f_ishift)
    img_back = cv2.magnitude(img_back[:, :, 0], img_back[:, :, 1])
    img_back = cv2.normalize(img_back, None, 0, 255, cv2.NORM_MINMAX).astype(np.uint8)

    return img, img_back, magnitude_spectrum_original, magnitude_spectrum_filtered

#processar as imagens e ,mostrar
img1, img_back1, mag_orig1, mag_filt1 = process_image_rf("Cerebro-RaioX.png")
img2, img_back2, mag_orig2, mag_filt2 = process_image_rf("juggernaut.png")

plt.figure(figsize=(12, 8))

plt.subplot(3, 2, 1)
plt.imshow(img1, cmap='gray')
plt.title('Original 1'), plt.axis('off')

plt.subplot(3, 2, 3)
plt.imshow(mag_orig1, cmap='gray')
plt.title('Espectro Original 1'), plt.axis('off')

plt.subplot(3, 2, 5)
plt.imshow(mag_filt1, cmap='gray')
plt.title('Espectro com Filtro 1 (RF)'), plt.axis('off')

plt.subplot(3, 2, 2)
plt.imshow(img2, cmap='gray')
plt.title('Original 2'), plt.axis('off')

plt.subplot(3, 2, 4)
plt.imshow(mag_orig2, cmap='gray')
plt.title('Espectro Original 2'), plt.axis('off')

plt.subplot(3, 2, 6)
plt.imshow(mag_filt2, cmap='gray')
plt.title('Espectro com Filtro 2 (RF)'), plt.axis('off')

plt.tight_layout()
plt.show()

"""#Operações Morfológicas"""

import cv2
import matplotlib.pyplot as plt
import numpy as np

#funçao de binarização - percorrer pixel por pixel
def binarizar_manual(img, limiar=127):
    binaria = np.zeros_like(img)

    for i in range(len(img)):
        for j in range(len(img[0])):
            if img[i][j] > limiar:
                binaria[i][j] = 255
            else:
                binaria[i][j] = 0

    return binaria

#carregar imagem
def load_img(path):
    img_rgb = cv2.imread(path, cv2.IMREAD_GRAYSCALE)
    if img_rgb is None:
        raise ValueError(f"Imagem não encontrada em {path}")
    return img_rgb

img_cerebro = load_img('/content/Cerebro-RaioX.png')
img_juggernaut = load_img('/content/juggernaut.png')
#img_babuino = load_img('/content/babuino.jpg')
#img_arara = load_img('/content/arara.jpg')

#aplicar a binarizaçao nas imagens
img_binaria_cerebro = binarizar_manual(img_cerebro, 127)
img_binaria_juggernaut = binarizar_manual(img_juggernaut, 127)
#img_binaria_babuino = binarizar_manual(img_babuino, 127)
#img_binaria_arara = binarizar_manual(img_arara, 127)

#exibir as imagens binarizadas
plt.figure(figsize=(5, 5))
plt.title("Imagem Binarizada (Manual)")
plt.imshow(img_binaria_juggernaut, cmap='gray')
plt.axis('off')
plt.show()

plt.figure(figsize=(5, 5))
plt.title("Imagem Binarizada (Manual)")
plt.imshow(img_binaria_cerebro, cmap='gray')
plt.axis('off')
plt.show()

#plt.figure(figsize=(10,5))
#plt.subplot(1, 2, 1)
#plt.title("Babuino Binária")
#plt.imshow(img_binaria_babuino, cmap='gray')
#plt.axis('off')

#plt.subplot(1, 2, 2)
#plt.title("Arara Binária")
#plt.imshow(img_binaria_arara, cmap='gray')
#plt.axis('off')

plt.show()

"""2.1 – Dilatação"""

import cv2
import matplotlib.pyplot as plt
import numpy as np

#dilataçao
def dilatacao(img, kernel_size=3):
    offset = kernel_size // 2
    padded = np.zeros((len(img) + 2 * offset, len(img[0]) + 2 * offset))
    padded[offset:-offset, offset:-offset] = img

    result = np.zeros_like(img)

    #percorrer a imagem e aplicar a dilataçao
    for i in range(offset, len(padded) - offset):
        for j in range(offset, len(padded[0]) - offset):
            região = padded[i - offset:i + offset + 1, j - offset:j + offset + 1]
            if np.any(região == 255):  #verificar se algum pixel da regiao é 255
                result[i - offset, j - offset] = 255

    return result

#carregar as imagens binarizadas
def load_img(path):
    img_rgb = cv2.imread(path, cv2.IMREAD_GRAYSCALE)
    if img_rgb is None:
        raise ValueError(f"Imagem não encontrada em {path}")
    return img_rgb

def load_img2(path):
    img_rgb = cv2.imread(path, cv2.IMREAD_GRAYSCALE)
    if img_rgb is None:
        raise ValueError(f"Imagem não encontrada em {path}")

    #binarizar a img
    img_binarizada = binarizar_manual(img_rgb)

    return img_binarizada

img_cerebro = load_img('/content/Cerebro-RaioX.png')
img_juggernaut = load_img2('/content/juggernaut.png')
#img_babuino = load_img('/content/babuino.jpg')
#img_arara = load_img('/content/arara.jpg')

#aplicar a dilataçao nas imagens binarizadas
img_dilatada_cerebro = dilatacao(img_cerebro)
img_dilatada_juggernaut = dilatacao(img_juggernaut)
#img_dilatada_babuino = dilatacao(img_babuino)
#img_dilatada_arara = dilatacao(img_arara)

#exibir as imagens dilatadas
plt.figure(figsize=(10, 5))
plt.subplot(1, 2, 1)
plt.title("Cerebro Dilatada")
plt.imshow(img_dilatada_cerebro, cmap='gray')
plt.axis('off')

plt.figure(figsize=(6, 6))
plt.title("Juggernaut Dilatada")
plt.imshow(img_dilatada_juggernaut, cmap='gray')
plt.axis('off')
plt.show()

#plt.figure(figsize=(10, 5))
#plt.subplot(1, 2, 1)
#plt.title("Babuino Dilatada")
#plt.imshow(img_dilatada_babuino, cmap='gray')
#plt.axis('off')

#plt.subplot(1, 2, 2)
#plt.title("Arara Dilatada")
#plt.imshow(img_dilatada_arara, cmap='gray')
#plt.axis('off')

plt.show()

"""#2.2 – Erosão"""

import cv2
import matplotlib.pyplot as plt
import numpy as np

#funcao de erosao
def erosao(img, kernel_size=3):
    offset = kernel_size // 2
    padded = np.full((len(img) + 2 * offset, len(img[0]) + 2 * offset), 255)
    padded[offset:-offset, offset:-offset] = img

    resultado = np.zeros_like(img)

    #percorrer a img e aplicar a erosa em cada pixel
    for i in range(offset, len(padded) - offset):
        for j in range(offset, len(padded[0]) - offset):
            regiao = padded[i - offset:i + offset + 1, j - offset:j + offset + 1]
            if np.all(regiao == 255):
                resultado[i - offset, j - offset] = 255

    return resultado

#carregar a imagem
def load_img(path):
    img_rgb = cv2.imread(path, cv2.IMREAD_GRAYSCALE)
    if img_rgb is None:
        raise ValueError(f"Imagem não encontrada em {path}")
    return img_rgb

img_cerebro = load_img('/content/Cerebro-RaioX.png')
img_juggernaut = load_img('/content/juggernaut.png')

#binarizar a img
img_binaria_cerebro = np.where(img_cerebro > 127, 255, 0).astype(np.uint8)
img_binaria_juggernaut = np.where(img_juggernaut > 127, 255, 0).astype(np.uint8)

#aplicar erosao
img_erosao_cerebro = erosao(img_binaria_cerebro)
img_erosao_juggernaut = erosao(img_binaria_juggernaut)

#exibir as imagens
plt.figure(figsize=(10, 5))
plt.subplot(1, 2, 1)
plt.title("Cérebro Original (Binarizado)")
plt.imshow(img_binaria_cerebro, cmap='gray')
plt.axis('off')

plt.subplot(1, 2, 2)
plt.title("Cérebro - Erosão")
plt.imshow(img_erosao_cerebro, cmap='gray')
plt.axis('off')
plt.show()

plt.figure(figsize=(10,5))
plt.subplot(1, 2, 1)
plt.title("Juggernaut(Binarizado)")
plt.imshow(img_binaria_juggernaut, cmap='gray')
plt.axis('off')

plt.subplot(1, 2, 2)
plt.title("Juggernaut - Erosão")
plt.imshow(img_erosao_juggernaut, cmap='gray')
plt.axis('off')
plt.show()

"""#2.3 – Abertura (erosão seguida de dilatação)"""

#erosao seguida de dilataçao - remover ruido e remover pequenos detalhes
def abertura(img, kernel_size=3):
    return dilatacao(erosao(img, kernel_size), kernel_size)

img_abertura_cerebro = abertura(img_binaria_cerebro)
img_abertura_juggernaut = abertura(img_binaria_juggernaut)
#img_abertura_babuino = abertura(img_binaria_babuino)
#img_abertura_arara = abertura(img_binaria_arara)

cv2_imshow(img_abertura_cerebro)
cv2_imshow(img_abertura_juggernaut)
#cv2_imshow(img_abertura_babuino)
#cv2_imshow(img_abertura_arara)

"""#2.4 – Fechamento (dilatação seguida de erosão)"""

#dilataçao seguida de erosao - fechar lacunas em regioes brancas
def fechamento(img, kernel_size=3):
    return erosao(dilatacao(img, kernel_size), kernel_size)

img_fechamento_cerebro = fechamento(img_binaria_cerebro)
img_fechamento_juggernaut = fechamento(img_binaria_juggernaut)
#img_fechamento_babuino = fechamento(img_binaria_babuino)
#img_fechamento_arara = fechamento(img_binaria_arara)

cv2_imshow(img_fechamento_cerebro)
cv2_imshow(img_fechamento_juggernaut)
#cv2_imshow(img_fechamento_babuino)
#cv2_imshow(img_fechamento_arara)

"""#Binarização"""

#transformar a imagem em preto e branco no padrao 127
def binarizar(img, limiar=127):
    #criar imagem binarizada
    binaria = [[0 for _ in range(len(img[0]))] for _ in range(len(img))]

    for i in range(len(img)):
        for j in range(len(img[0])):
            binaria[i][j] = 255 if img[i][j] > limiar else 0

    return binaria

"""#Usabilidade

"""

#carregar as imagens binarizadas
img_cerebro = load_img('/content/Cerebro-RaioX.png')
img_juggernaut = load_img('/content/juggernaut.png')

#aplicando a binarizaçao
img_binaria_cerebro = binarizar(img_cerebro, 127)
img_binaria_cerebro = np.array(img_binaria_cerebro, dtype=np.uint8)

img_binaria_juggernaut = binarizar(img_juggernaut, 127)
img_binaria_juggernaut = np.array(img_binaria_juggernaut, dtype=np.uint8)
#img_babuino = load_img('/content/babuino.jpg')
#img_arara = load_img('/content/arara.jpg')

#aplicar as operaçoes morfologicas
#img_dilatada_babuino = dilatacao(img_babuino)
#img_erodida_babuino = erosao(img_babuino)
#img_aberta_babuino = abertura(img_babuino)
#img_fechada_babuino = fechamento(img_babuino)

img_dilatada_cerebro = dilatacao(img_binaria_cerebro)
img_erodida_cerebro = erosao(img_binaria_cerebro)
img_aberta_cerebro = abertura(img_binaria_cerebro)
img_fechada_cerebro = fechamento(img_binaria_cerebro)

img_dilatada_juggernaut = dilatacao(img_binaria_juggernaut)
img_erodida_juggernaut = erosao(img_binaria_juggernaut)
img_aberta_juggernaut = abertura(img_binaria_juggernaut)
img_fechada_juggernaut = fechamento(img_binaria_juggernaut)

#img_dilatada_arara = dilatacao(img_arara)
#img_erodida_arara = erosao(img_arara)
#img_aberta_arara = abertura(img_arara)
#img_fechada_arara = fechamento(img_arara)

#exibir os resultados
cv2_imshow(img_dilatada_cerebro)
cv2_imshow(img_erodida_cerebro)
cv2_imshow(img_aberta_cerebro)
cv2_imshow(img_fechada_cerebro)

cv2_imshow(img_dilatada_juggernaut)
cv2_imshow(img_erodida_juggernaut)
cv2_imshow(img_aberta_juggernaut)
cv2_imshow(img_fechada_juggernaut)

#cv2_imshow(img_dilatada_babuino)
#cv2_imshow(img_erodida_babuino)
#cv2_imshow(img_aberta_babuino)
#cv2_imshow(img_fechada_babuino)

#cv2_imshow(img_dilatada_arara)
#cv2_imshow(img_erodida_arara)
#cv2_imshow(img_aberta_arara)
#cv2_imshow(img_fechada_arara)